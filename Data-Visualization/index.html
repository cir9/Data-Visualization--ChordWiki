<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>Chord Visualization</title>
    <link href=".\node_modules\bootstrap\dist\css\bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <link href=".\scripts\style.css" rel="stylesheet" crossorigin="anonymous">

</head>

<body>
    <svg class="position-absolute">
        <defs>
            <pattern id="st-0"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-0)" />
            </pattern>
            <pattern id="st-1"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-1)" />
            </pattern>
            <pattern id="st-b2"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-1)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-2); stroke-width:1.414" />
            </pattern>
            <pattern id="st-2"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-2)" />
            </pattern>
            <pattern id="st-b3"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-2)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-3); stroke-width:1.414" />
            </pattern>
            <pattern id="st-3"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-3)" />
            </pattern>
            <pattern id="st-4"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-4)" />
            </pattern>
            <pattern id="st-b5"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-4)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-5); stroke-width:1.414" />
            </pattern>
            <pattern id="st-5"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-5)" />
            </pattern>
            <pattern id="st-b6"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-5)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-6); stroke-width:1.414" />
            </pattern>
            <pattern id="st-6"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-6)" />
            </pattern>
            <pattern id="st-b7"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-6)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-7); stroke-width:1.414" />
            </pattern>
            <pattern id="st-7"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-7)" />
            </pattern>

            <pattern id="dash-line"  patternUnits="userSpaceOnUse"  width="6" height="2">
                <rect width="3" height="2" style="fill:rgba(255,255,255,0.5)" />
                <rect width="6" x="3" height="2" style="fill:#6b5393ee" />
            </pattern>
            <filter id="glow">
				<fegaussianblur class="blur" result="coloredBlur" stddeviation="2"></fegaussianblur>
				<femerge>
					<femergenode in="coloredBlur"></femergenode>
                    <femergenode in="coloredBlur"></femergenode>
                    <femergenode in="coloredBlur"></femergenode>
					<femergenode in="SourceGraphic"></femergenode>
				</femerge>
			</filter>
        </defs>
    </svg>


    <div id="app">
        <chord-info :chord="currentShownChordTip" :col-index="colIndex"></chord-info>

            
        <div class="bg-dark text-secondary text-center hero d-flex flex-wrap">
            
            <svg class="flex-grow-1">
                <g id="large-bg"></g>
                <g>
                    <text class="display-5 fw-bold text-white" fill="white" x="50%" y="300" text-anchor="middle" >
                        Data Visualization of Chord Usage Statistics
                    </text>
                    <text class="lead" fill="rgb(155,187,155)" x="50%" y="390" text-anchor="middle" >
                        J-pop 中和弦的使用趋势和数据可视化
                    </text>
                    <text class="lead" fill="rgb(155,155,155)" x="50%" y="640" text-anchor="middle" >
                        Data from ja.chordwiki.org
                    </text>
                </g>
            </svg>
        </div>
        

        <div class="b-example-divider align-items-center sticky-top row m-0 w-100" id="time-picker">
            <div v-for="(column,index) in heads" :class="`col${index==colIndex?' selected':''}`"
                 @click="SelectHeadIndex(index)" v-cloak>
                {{ column.toUpperCase() }}
            </div>
        </div>



        <div class="px-4 pt-5 mt-5 text-center">

            <div>


            </div>

            <div class="two-rows">
            
                <div>
                    <h1 class="display-6 fw-bold">主调雷达图</h1>
                    <div class="col-lg-6 mx-auto">
                        <p class="lead mb-4">
                            统计了各主调在所有音乐中的占比
                        </p>
                    </div>
                    <div>{{ GetCurrentYearTitle() }}</div>
                            
                    <div id="kp-diag" class="pb-5">
    
                    </div>
                </div>
        
                <div class="h-100 w-50">
                    <h1 class="display-6 fw-bold">曲速柱状图</h1>
                    <div class="col-lg-6 mx-auto">
                        <p class="lead mb-4">
                            统计了各年度热门曲目的bpm分布情况
                        </p>
                    </div>
    
                    
            
                    <div id="bpm-diag" class="py-5">
    
                    </div>
                </div>
            </div>


        </div>


        <div class="b-example-divider"></div>

        <div class="two-rows">
            <div>
                <div class="px-4 pt-5 mt-5 text-center pb-5">
                    <h1 class="display-6 fw-bold">和弦气泡图</h1>
                    <div class="col-lg-6 mx-auto">
                        <p class="lead mb-4">
                            统计了音乐中常见和弦的出现率
                        </p>
                    </div>
                    <!-- <div class="lead fs-small col-lg-6 mx-auto">
                        (单位：次/曲)
                    </div> -->
                    <div id="chord-one-diag">
                        <svg height="720px">
                            
                        </svg>
                    </div>
                </div>    
            </div>
            <div>

                <div class="px-4 pt-5 mt-5 text-center pb-5">
                    <h1 class="display-6 fw-bold">终止和弦环状图</h1>
                    <div class="col-lg-6 mx-auto">
                        <p class="lead mb-4">
                            统计了音乐结尾<br>最后一个和弦的使用情况
                        </p>
                    </div>
                    <div>{{ GetCurrentYearTitle() }}</div>
                    <!-- <div class="lead fs-small col-lg-6 mx-auto">
                        (单位：次/曲)
                    </div> -->
                    <div id="chord-final-diag">
                        <svg height="550px">
                            
                        </svg>
                    </div>
                </div>        
            </div>
        
        </div>
    






        <div class="b-example-divider"></div>

        <div class="px-4 pt-5 mt-5 text-center">
            <h1 class="display-6 fw-bold">和弦连接图</h1>
            <div class="col-lg-6 mx-auto">
                <p class="lead mb-4">
                    统计了音乐中任意两个相邻和弦连接的出现率
                </p>
            </div>
        </div>



        <div id="chord-diag" class="pb-6 border-bottom">

            <div id="my_dataviz" class="d-flex justify-content-center">
                <div id="chord-diagram">
                    
                    <div class="d-flex justify-content-center">
                        <div id="chord-title" class="pt-4"></div>
                    </div>
                </div>
                <div>
                    <div class="prog-header py-2" v-if="currentProgressionPoss">
                        <div class="note-text bass-prog" v-cloak>
                            {{ currentProgressionName }}
                        </div>
                        <!-- <div class="ps-4 unit-small flex-grow-1" v-cloak>{{ `${(CalcWeightPercentage() * 100).toFixed(1)}%` }}</div> -->
            
                        <div class="prog-year-bar">
                            {{ GetCurrentYearText()}}
                        </div>

                        <div class="prog-unit-bar">
                            <span class="unit-small" v-if="currentProgressionPoss != ''">出现率：</span>
                            <span class="unit-main" v-cloak>
                                {{ currentProgressionPoss }}
                            </span>
                            <span class="unit-small" v-if="currentProgressionPoss != ''">%</span>
                        </div>

                    </div>  
                    <div id="prog-list" class="d-flex flex-column">

                        <div class="flex-grow-1 d-block">
                            <Progression v-for="{chords, p, hist} in GetDeriveredProgressions(currentProgression)"
                                :key="chords" :data="chords" :p="p" :hist="hist" :max="currentProgressionMax"
                                :col="colIndex" :padding="1"
                                @select-column="SelectHeadIndex"
                                @select-chord="SelectChord"
                                @chord-tip="chordTip"
                            />
                        </div>
                    </div>
                </div>

            </div>


        </div>

        <div class="b-example-divider"></div>

                
        <!-- <div class="px-4 pt-5 mt-5 text-center">
            <h1 class="display-6 fw-bold">和弦进行表</h1>
            <div class="col-lg-6 mx-auto">
                <p class="lead mb-4">
                    统计了各音乐使用的和弦进行
                </p>
            </div>
        </div>

        
        <div id="bpm-diag" class="pb-5">

        </div> -->

        <!-- <div class="b-example-divider"></div> -->
    </div>

    
    <!-- @click.stop="$emit('selectChord', chord, i)" -->
    <template id="t-progression">
        <div class="d-flex flex-row chord-line">
            <div class="chord-block tween" 
                v-for="(chord,i) in data" 
                @mouseover="$emit('chordTip', $event, chord)" @mouseleave="hideChordTip"
                @click.stop="PlayChord(chord)"
                :style="`--this-color: var(--color-${GetChordBassNote(chord)});`" >
                <svg class="chord-svg" >
                    <g  >
                    <rect :x="`${padding}%`" :y="`${padding*2}%`" :width="`${100-padding*2}%`" height="82%" fill="#f6f6f6"/>
                    <rect :x="`${padding}%`" y="84%" :width="`${100-padding*2}%`" :height="`${16-padding*2}%`" :fill="`url(#st-${GetChordBassNote(chord)})`"/>
                    <foreignObject width="100%" height="100%">
                        <div class="chord-text-fgn">
                            <div class="note-text" v-html="ReplaceBracket(chord)"></div>
                        </div>
                    </foreignObject>
                    </g>
                </svg>
            </div>

            <div class="flex-grow-1 d-flex" >
                <svg class="histogram">
                    <g  v-for="(v,i) in hist"
                        height="100%"
                    >
                        <rect class="hist-sub"
                            :x="`${(i<2?i:i+0.3)/(hist.length+0.3)*100}%`"    y="0%"
                            :width="`${1/(hist.length+0.3)*100}%`"        height="100%" 
                            fill="#ffffff00"
                            @click.stop="$emit('selectColumn', i)"
                            @mouseover ="watchingIndex=i"
                            @mouseleave="watchingIndex=-1"
                        />

                        <rect class="hist-bar"
                            :x="`${(i<2?i:i+0.3)/(hist.length+0.3)*100}%`"    :y="`${(1-v/max*0.8)*100}%`"
                            :width="`${1/(hist.length+0.3)*95}%`"        :height="`${v/max*80}%`" 
                            :fill="isCurrentCol(i)?'#4a05a0':'#555'"
                            @click.stop="$emit('selectColumn', i)"
                            @mouseover ="watchingIndex=i"
                            @mouseleave="watchingIndex=-1"
                            :title="`${v.toFixed(3)}% - ${GetColTitle(i)}`"
                        />

                    </g>

                    <rect 
                        :x="`${2/(hist.length+0.3)*100}%`"    :y="`${(1-hist[1]/max*0.8)*100}%`"
                        :width="`${hist.length/(hist.length+0.3)*95}%`"  height="2%" 
                        fill="url(#dash-line)" stroke-dasharray="5,5"        
                    />
                </svg>
                <div class="hist-text">
                    <div class="unit-small text-align-right">
                        {{ watchingIndex==-1 ? ( padding == 0 ? '出现率' : ''): headsTrunc[watchingIndex] }}
                    </div>
                    <div class="unit-main" v-cloak>
                        <span class="unit-main" v-cloak>
                            {{ watchingIndex==-1 ? p.toFixed(3): hist[watchingIndex].toFixed(3) }}
                        </span>
                        <span class="unit-small">%</span>
                    </div>

                </div>
            </div>
        </div>
    </template>

    <template id="t-chord-info">
        <div class="chord-info">

        <Progression
            :data="[chord]" :p="GetP(chord)" :hist="GetPs(chord)" :max="GetPMax(chord)"
            :col="colIndex" :padding="0"
            @select-column="SelectHeadIndex"
        />

            <!-- <svg width="100%" height="100%">
                <rect x="0%" y="90%" width="100%" height="10%" :fill="`url(#st-${GetChordBassNote(chord)})`"/>
                <text x="50%" y="50%" text-anchor="middle" font-size="24px" fill="black">{{ ReplaceBracket(chordToText(chordObj)) }}</text>


                <foreignObject width="100%" height="100%">
                    <div class="">
                        <div class="note-text" v-html="ReplaceBracket(chordToText(chordObj))"></div>
                    </div>

                    <Progression
                        :data="[chord]" :p="GetP(chord)" :hist="GetPs(chord)" :max="GetPMax(chord)"
                        :col="colIndex"
                        @select-column="SelectHeadIndex"
                    />
                </foreignObject>
            </svg> -->
        </div>
    </template>


    <script src=".\node_modules\d3\dist\d3.js"></script>
    <script src=".\node_modules\tone\build\Tone.js"></script>
    <script src=".\node_modules\vue\dist\vue.global.js"></script>
    <script src=".\scripts\chorddiag.js"></script>




    <!-- definitions -->
    <script>


        const data_of_years = {}
        const data_two_chords = {}  
        const data_keys_raw = {}      
        const data_keys = []
        const data_one_chords = {}
        let colIndex = 0
        let playIndex = 0        
        let currentChordFilter = null
        let currentSelectedBass = 0
        let currentMatrixSum = 0
        let isFromMode = true
        
        const heads = ['total', 'weighted',
              '2012', '2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022']
        const headsTrunc = ['TOTAL', 'WEIGHTED',
              '2012', '2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022']

        const headsTitle = ['总计', '热门总计 (2012-2022年)',
              '2012年热门', '2013年热门', '2014年热门', '2015年热门', '2016年热门',
              '2017年热门', '2018年热门', '2019年热门', '2020年热门', '2021年热门', '2022年热门']

    </script>


    <!-- definitions & largeBg -->
    <script>

        const noteFromTone = ['1','b2','2','b3','3','4','b5','5','b6','6','b7','7']
        const c_ScaleFromTone = ['C','C♯/D♭','D','D♯/E♭','E','F','F♯/G♭','G','G♯/A♭','A','A♯/B♭','B']
        const scaleFromTone = ['1','♯1/♭2','2','♯2/♭3','3','4','♯4/♭5','5','♯5/♭6','6','♯6/♭7','7']

        const chord_name_map = {
            'bI'   : 11, 'I'   : 0,  '#I'   : 1,
            'bII'  : 1,  'II'  : 2,  '#II'  : 3,
            'bIII' : 3,  'III' : 4,  '#III' : 5,
            'bIV'  : 4,  'IV'  : 5,  '#IV'  : 6,
            'bV'   : 6,  'V'   : 7,  '#V'   : 8,
            'bVI'  : 8,  'VI'  : 9,  '#VI'  : 10,
            'bVII' : 10, 'VII' : 11, '#VII' : 0,
        }
        const note_name_map = {
            'b1' : 11, '1' : 0,  '#1' : 1,
            'b2' : 1,  '2' : 2,  '#2' : 3,
            'b3' : 3,  '3' : 4,  '#3' : 5,
            'b4' : 4,  '4' : 5,  '#4' : 6,
            'b5' : 6,  '5' : 7,  '#5' : 8,
            'b6' : 8,  '6' : 9,  '#6' : 10,
            'b7' : 10, '7' : 11, '#7' : 0,
        }
        const reg_chordname = /[#b]?(?:VI{1,2}|I?V|I{1,3})/
        const reg_bassname = /\/([#b]?[1-7])/

        function GetChordBass(chord){
            let match_bassname = reg_bassname.exec(chord)
            if (match_bassname)
                return note_name_map[match_bassname[1]]

            let match_chordname = reg_chordname.exec(chord)
            if (match_chordname)
                return chord_name_map[match_chordname[0]]

            return 0
        }

        const GetChordBassNote = (chord) => noteFromTone[GetChordBass(chord)]

        const ReplaceBracket = (text) =>
            text.replaceAll(/#/g,"♯")
                .replaceAll(/b/g, "♭")
                .replaceAll(/(\(.*?\)|sus[24])/g,"<span>$1</span>")
         

        let progression_index = 0
        let progressions = [
            ['IV', 'V', 'IIIm', 'VIm'],
            ['VIm', 'IV', 'V', 'I'],
            ['IV', 'III', 'VIm', 'I'],
            ['I', 'III', 'VIm', 'II'],
        ]




        // let shown_progression = ['IV', 'V', 'IIIm', 'VIm']

        // const observer = new IntersectionObserver( 
        //     ([e]) => e.target.classList.toggle("is-pinned", e.intersectionRatio < 1),
        //     { threshold: [1] }
        // );
        // observer.observe(document.querySelector("#time-picker"));


        function update_largeBg(prog){
          
            const largeBg = d3.select("#large-bg")
            

            const rect = (e,delay) =>
                e.append('rect').attr('y','-20%').attr('width','25%').attr('height','140%')
                    .style("mix-blend-mode", "hue")
                    .style("fill", d=>`url(#st-${GetChordBassNote(d)})` ).style('opacity','0')
                    .transition().duration(1500).delay(delay).style('opacity','0.01')
                    .attr('x', (d,i)=>`${i*25}%`)

            const text = (e,delay) =>
                e.append('text').attr('y','85%')
                    .attr('class', 'chord-score chord-name')
                    .style('font-size','64').attr('fill', 'white')
                    .attr('text-anchor', 'middle')
                    .text((d,i)=>d).style('opacity','0')
                    .transition().duration(1500).delay(delay).style('opacity','0.01')
                    .attr('x', (d,i)=>`${(i+0.5)*25}%`)

            const delay = (d,i)=>i*500

            largeBg.selectAll('g').data(prog) //, d=>d)
                .join(
                    enter => {
                        let g = enter.append('g')
                        rect(g, delay)
                        text(g, delay)
                        return g 
                    },
                    update => {
                        update.select('rect').transition().duration(1400).delay(delay).attr('x', (d,i)=>`${i*25}%`).style('opacity','0').remove()
                        update.select('text').transition().duration(1400).delay(delay).attr('x', (d,i)=>`${(i+0.5)*25}%`).style('opacity','0').remove()
                        rect(update, delay)
                        text(update, delay)
                        return update
                    },
                    exit => exit.selectAll('*').transition().style('opacity','0').remove()
                )
  
        }
        update_largeBg(progressions[0])

        d3.select("#large-bg").on('click', (e,d)=>{
            progression_index = (progression_index+1)%4
            update_largeBg(progressions[progression_index])
        })
    </script>
    
    <!-- tooltip & tone.js -->
    <script>

        let chordTip = null
        const showChordTip = function(event, chord) {
            if (chord=='Other') return
            chordTip = chordTip || d3.select('#chord-info')
            let t = event.y + window.pageYOffset -120
            chordTip
                .style("left", (event.x-165) + "px")
                .style("top", (event.y -120 > 0 ? t: t + 200) + "px")
                .style('display', 'block')
                .transition().duration(100)
                .style("opacity", 1)
            app._instance.data.currentShownChordTip = chord
        }

        var hideChordTip = function(event) {
            chordTip.interrupt()
                .transition()
                .duration(300)
                .style("opacity", 0)
                .end().then(() => 
                    chordTip.style('display', 'none')
                        .style("left","0px")
                        .style("top", "0px")
                ).catch(e=>{})
        }


        const bassNotes = ['G3','Ab3','A3','Bb3','B3','C4','Db4','D4','Eb4','E4','F4','Gb4','G4','Ab4']
        const glassNotes = ['B3',
            'C4','Db4','D4','Eb4','E4','F4','Gb4','G4','Ab4','A4','Bb4','B4',
            'C5','Db5','D5','Eb5','E5','F5','Gb5','G5','Ab5','A5','Bb5','B5',
            'C6','Db6','D6','Eb6','E6','F6','Gb6','G6','Ab6','A6','Bb6',
        ]

        const synthA = new Tone.PolySynth(Tone.FMSynth).toDestination();
        const synthB = new Tone.PolySynth(Tone.AMSynth).toDestination();

        const bass = new Tone.Sampler({
            urls: (()=>{
                let res = {}
                Array(...bassNotes).forEach(e => {
                    res[e] = `${e}.mp3`
                })
                return res
            })(),
            release: 1,
            baseUrl: "../sound/bass/",
        }).toDestination();

        const glass = new Tone.Sampler({
            urls: (()=>{
                let res = {}
                Array(...glassNotes).forEach(e => {
                    res[e] = `${e}.mp3`
                })
                return res
            })(),
            release: 1,
            baseUrl: "../sound/glass/",
        }).toDestination();

    </script>

    <!-- play chords -->
    <script>
        let width = 500

        range = length => [...Array(length).keys()]



        function playChord({playingKeys:{bass: b, notes}}){
            bass.releaseAll("+0")
            glass.releaseAll("+0")

            let length = notes.length
            let now = Tone.now()
            bass.triggerAttackRelease(b, "2m", now, 0.33)
            notes.forEach((n, i)=>{
                glass.triggerAttackRelease(n, "2m", now + i * 0.15 / length, i==0 ? 0.15: 0.3 * (i < 4 ? Math.pow(0.9, i): Math.pow(0.8, i)))
            })
        }


        function PlayChord(chord){
            let c = parseChord(chord)
            if(!c) return
            let t = getChordTones(c)
            console.log(chord)
            console.log(c)
            console.log(t.playingKeys.bass)
            console.log(t.playingKeys.notes)
            playChord(t)
        }

    </script>

    <!-- vue -->
    <script>
        const app = Vue.createApp({
            data() { return {
                currentProgression: [],
                currentProgressionMax: 0,
                heads, colIndex:0,
                currentProgressionName: '',
                currentProgressionPoss: '',
                currentShownChordTip: '',
            }},
            computed:{

            },
            methods:{
                chordTip(e, c){
                    showChordTip(e, c)
                },
                GetDeriveredProgressions(prog){
                    let r = (data_two_chords[prog.join(' ')]||[]).map(
                        ({chords, in_years})=>({
                            chords, 
                            p: (in_years[colIndex]||0.0), 
                            hist: in_years,
                        })
                    )
                    this.currentProgressionMax = Math.max(...r.map(e=>Math.max(...e.hist)))
                    // r.sort((a,b)=>b.p-a.p)
                    return r
                },
                SelectHeadIndex(index, t){
                    this.colIndex = colIndex = index
                    let mat = matrixFromColumn(data_of_years, heads[this.colIndex], currentChordFilter)
                    
                    if(t) 
                        update(mat, 
                            currentChordFilter
                            ? `${headsTitle[colIndex]} - ${t}和弦低音为 <span class="note-text">${scaleFromTone[currentSelectedBass]}</span>`
                            : headsTitle[colIndex])
                    else
                        update(mat, 
                            currentChordFilter
                            ? `${headsTitle[colIndex]} - 起始和弦低音为 <span class="note-text">${scaleFromTone[currentSelectedBass]}</span>`
                            : headsTitle[colIndex])

                    if (this.currentProgression[0] != null){
                        
                        this.currentProgressionName = `${scaleFromTone[this.currentProgression[0]]} → ${scaleFromTone[this.currentProgression[1]]}`
                        this.currentProgressionPoss = (+currentMatrix[this.currentProgression[0]][this.currentProgression[1]]).toFixed(3)
                    
                    }
                    updateKPDiag()
                    updateHandlers.forEach(e=>e(colIndex))
                },
                CalcWeightPercentage(){
                    return (+this.currentProgressionPoss) / currentMatrixSum
                },
                SelectChord(chord, index){
                    currentSelectedBass = GetChordBass(chord)
                    currentChordFilter = index==0? (f,t)=>t==currentSelectedBass :  (f,t)=>f==currentSelectedBass
                    this.currentProgression[1 - index] = currentSelectedBass

                    this.SelectHeadIndex(this.colIndex, index==0?'目标':'起始')
                    isFromMode = index==0
                },
                GetCurrentYearText(){
                    return heads[this.colIndex].toUpperCase()
                },
                GetCurrentYearTitle(){
                    return headsTitle[this.colIndex]
                }
            }
        })
        app.component('Progression', {
            template: '#t-progression',
            props: ['data', 'p', 'hist', 'max', 'col', 'padding'],
            data(){ return{
                watchingIndex: -1,
                headsTrunc
            }},
            methods:{
                PlayChord,
                GetChordBassNote, 
                hideChordTip,
                GetCurrentDataHtml(cols){
                    return ReplaceBracket(cols[colIndex])
                },
                ReplaceBracket,
                isCurrentCol(index){
                    return index==this.col
                },
                GetColTitle(col){
                    return headsTitle[colIndex]
                }
            },
        })
        app.component('ChordInfo', {
            template: '#t-chord-info',
            props: ['chord', 'colIndex'],
            data(){ return{

            }},
            computed: {
                chordObj(){
                    return parseChord(this.chord) || {};
                }
            },
            methods:{
                GetPs(chord){
                    return chord && Object.keys(data_one_chords).length !== 0 ? data_one_chords[chord] : [0,0]
                },
                GetP(chord){
                    return chord && Object.keys(data_one_chords).length !== 0 && data_one_chords[chord] ? data_one_chords[chord][colIndex]: 0
                },
                GetPMax(chord){
                    return chord && Object.keys(data_one_chords).length !== 0 && data_one_chords[chord] ? d3.max(data_one_chords[chord]): 1
                },
                SelectHeadIndex(index, t){
                    app._instance.methods.SelectHeadIndex(index, t)
                },
                GetChordBassNote, 
                ReplaceBracket,
                chordToText,
            },
        })

        app.mount('#app')

        chordTip = d3.select('.chord-info')
    </script>


    <!-- csv reading -->
    <script>
        
        d3.dsv(",", "../data/conn_chords.csv", () =>{}, (d) => {
            for(let column in d){
                (data_of_years[column] || (data_of_years[column] = [])).push(d[column])
            }
            
        }).then(c=>{
            let mat = matrixFromColumn(data_of_years, 'total')
            update(mat, headsTitle[0])

        })

        d3.dsv(",", "../data/two_chords.csv", () =>{}, (d) => {
            (data_two_chords[d.semi] || (data_two_chords[d.semi] = [])).push({
                chords: d.key.split(' '),
                in_years: [...heads.map(e=>+d[e])]
            })
        }).then(c=>{
            console.log(data_two_chords)

        })

        d3.dsv(",", "../data/keys.csv", () =>{}, (d) => {
            if( (+d.key) < 0) return 
            data_keys_raw[circle_of_fifth[+d.key]] = {
                key: circle_of_fifth[+d.key],
                in_years: [...heads.map(e=>+d[e])]
            }
        }).then(c=>{
            data_keys.push(...Object.values(data_keys_raw).map(({key, in_years})=>({
                key,
                total: in_years[0],
                avg: in_years[1],
                min: d3.min(in_years),
                max: d3.max(in_years),
            })))
            console.log(data_keys)
            buildKp()
        })

        
    </script>

    <!-- chord diagram -->
    <script>



    const showProgDetail = function(event, d) {
        let data = app._instance.data
        data.currentProgression = [d.source.index, d.target.index]//.map(e=>`/${e}`)
        data.currentProgressionName = `${scaleFromTone[d.source.index]} → ${scaleFromTone[d.target.index]}`
        data.currentProgressionPoss = (+currentMatrix[d.source.index][d.target.index]).toFixed(3)
    }


    const title = d3.select("#chord-title").text('what')


    // create the svg area
    const svg = d3.select("#chord-diagram")
      .append("svg")
        .attr("width", 800)
        .attr("height", 600)
        // .attr('viewBox', '-300 -300 300 300')
      .append("g")
        .attr('alignment-baseline', 'central')
        .attr("transform", "translate(400,300)")
    
    const arcs =  svg.append("g").attr('id', 'chord-arcs')
    const ribbons = svg.append("g").attr('id', 'chord-ribbons')
    const arcTexts = svg.append('g').attr('id', 'chord-root')

    const ribbonPathGenerator = d3.ribbonArrow().radius(247).headRadius(13).padAngle(0.01)
    const arcPathGenerator = d3.arc().innerRadius(250).outerRadius(270).cornerRadius(3)



    const GetTranslate = (angle, width, height) => 
        `translate(${Math.sin(angle) * width} ${-Math.cos(angle) * height})`
    
    const GetArcTextTranslate = 
        ({startAngle, endAngle}, width, height) => GetTranslate((startAngle + endAngle)/2, width, height)
    

    const GetRibbonKey = ({source: {index: x0}, target: {index: x1}}) => 1 ? `${x0}-${x1}` : `${x1}-${x0}`

    function CacheChordData(data){
        let dict = {}

        for (let i = 0; i < data.length; i++) {
            const datum = data[i]
            dict[GetRibbonKey(datum)] = datum
        }

        return dict
    }


    d3.select("#my_dataviz").on('click', e=>{
        if(!currentChordFilter) return
        let mat = matrixFromColumn(data_of_years, heads[colIndex])
        currentChordFilter = null
        update(mat, headsTitle[colIndex])
    })

    let lastRibbonData, currentRibbonData
    let lastArcData, currentArcData

    const updateHandlers = []

    let currentMatrix
    function update(matrix, t){

        isFromMode = false

        currentMatrix = matrix
        title.html(t)
        
        lastRibbonData = currentRibbonData
        lastArcData = currentArcData

        var res = d3.chordDirected()
            .padAngle(0.02)
            // .sortSubgroups(d3.ascending)
            .sortChords(d3.descending)
            (matrix)
        
        

        arcs.datum(res)
        .selectAll("path")
        .data(
            d => d.groups,
            d => d.index,
        )
        .join(
            enter => enter.append("path").attr("d", arcPathGenerator).attr('id',d => 'arc-'+d.index).each(d=>d.p=1)
                .style("opacity", 0)
                .classed('selected-arc', (d,i)=> currentChordFilter && i==currentSelectedBass)
                .transition().duration(500).style('opacity', 1),
            update => update.classed('selected-arc', (d,i)=> currentChordFilter && i==currentSelectedBass)
                .filter(d=>!d.exit).transition().duration(500).style('opacity', 1).style('transform','scale(1)')
                .attrTween('d', (d,i)=>
                    t=>arcPathGenerator(d3.interpolate(lastArcData[i], d)(d.p=t))
                ),
            exit => exit.transition().duration(500).style('opacity',0).remove()    
        )
        .style('opacity', 1)
        .style("fill", d=>`url(#st-${noteFromTone[d.index]})`)
        .style('cursor', 'pointer')
        .on('click', (e,d)=>{
            if(currentSelectedBass != d.index || isFromMode || !currentChordFilter){
                let mat = matrixFromColumn(data_of_years, heads[colIndex], currentChordFilter = (f,t)=>f==d.index)
                currentSelectedBass = d.index
                update(mat, `${headsTitle[colIndex]} - 起始和弦低音为 <span class="note-text">${scaleFromTone[d.index]}</span>`)
            } else {
                let mat = matrixFromColumn(data_of_years, heads[colIndex], currentChordFilter = (f,t)=>t==d.index)
                currentSelectedBass = d.index
                update(mat, `${headsTitle[colIndex]} - 目标和弦低音为 <span class="note-text">${scaleFromTone[d.index]}</span>`)
                isFromMode = true
            }
            e.stopPropagation()
        })
        .on("mouseover", (e,d)=>{
            if(isFromMode){
                if(currentChordFilter && currentSelectedBass!=d.index)
                    showProgDetail(e,{target:{index: currentSelectedBass}, source:{index: d.index}})
            }else {
                if(currentChordFilter && currentSelectedBass!=d.index)
                    showProgDetail(e,{source:{index: currentSelectedBass}, target:{index: d.index}})
            }

            fade(0.05, 0.3)(e,d)
            d3.select(e.target).filter(d=>d.p==1).interrupt().
                transition().style('opacity', 1).style('transform','scale(1.02)')
        })
        .on("mouseleave", (e,d)=>{
            fade(0.8, 1)(e,d)
            d3.select(e.target).filter(d=>d.p==1).interrupt().
                transition().style('opacity', 1)  .style('transform','scale(1)')
        })


        arcTexts.datum(res)
        .selectAll("text")
        .data(
            d => d.groups,
            d => d.index,
        )
        .join(
            enter => enter.append('text').attr("dy", "0.35em")// .style('user-select', 'none')
                .style("opacity", 0).transition().duration(500).style('opacity', 1),
            update => update.transition().duration(500).style('opacity',1)
                .attrTween('transform', (d,i)=> 
                    t=>GetArcTextTranslate(d3.interpolate(lastArcData[i], d)(t), 295, 285)
                ),
            exit => exit.transition().duration(500).style('opacity',0).remove()    
        )
        .attr('class', 'note-text')
        .attr('transform', d=>GetArcTextTranslate(d, 295, 285))
        .attr('text-anchor', 'middle')
        .text((d,i)=>scaleFromTone[i]);




        ribbons.datum(res)
        .selectAll("path")
        .data(d => d, d => GetRibbonKey(d))
        .join(
            enter => enter.append("path").each(d=>d.p=1).attr('d', ribbonPathGenerator).style("mix-blend-mode", "multiply")
                .style("opacity", 0).transition().duration(500).style('opacity',0.8),
            update => update.filter(d=>!d.exit).transition().duration(500).style('opacity',0.8)
                .attrTween('d', d=> 
                    t=>ribbonPathGenerator(d3.interpolate(lastRibbonData[GetRibbonKey(d)], d)(d.p=t))
                ),
            exit => exit.each(d=>d.exit = true).transition().duration(500).style('opacity',0).remove()   
        )
        .attr('ribbon-key', d => GetRibbonKey(d))
        .style("fill", d=>`url(#st-${noteFromTone[d.source.index]})` )
        .on("mouseenter", showProgDetail )
        // .on("mouseleave", hideTooltip )
        
        currentRibbonData = CacheChordData(res)
        currentArcData = res.groups

    }

    function matrixFromColumn(data, column, filter){
        let res = Array(12)

        let keys = data['key']
        let weights = data[column]
        

        for (let index = 0; index < 12; index++) {
            res[index] = Array(12)
        }

        currentMatrixSum = 0

        for(let i=0; i<keys.length; i++){
            let key = keys[i]
            let w = +weights[i]


            let chords = key.split(' ')

            let source = +chords[0]
            let target = +chords[1]

            if(filter){
                if(!filter(source, target)) {
                    res[source][target] = 0
                    continue
                }
            }
            
            
            currentMatrixSum += w
            res[source][target] = w
        }

        

        return res
    }



    const fade = (opacity, arcOp) => (event, datum) => {
        if(currentChordFilter && !isFromMode)
            ribbons.selectAll("path").filter(d => d.target.index != datum.index && d.p>0.999 && !d.exit)
                .transition().style("opacity", opacity);
        else
            ribbons.selectAll("path").filter(d => d.source.index != datum.index && d.p>0.999 && !d.exit)
                .transition().style("opacity", opacity);
    }


    
    </script>

    <!-- key distribution diagram -->
    <script>

        const circle_of_fifth = [0,7,2,9,4,11,6,1,8,3,10,5]

        const kp_width = 700
        const kp_height = 700
        const kp_margin = 10
        let kp_innerRadius = kp_width / 6
        let kp_outerRadius = kp_width / 2 - kp_margin

        let kp_current_line
        let kp_last_line_data

        let kp_x = d3.scaleLinear()
            .domain([0,12])
            .range([0, 2 * Math.PI])


        let line = d3.lineRadial()
            .curve(d3.curveLinearClosed)
            .angle(d => kp_x(d.key))

        let area = d3.areaRadial()
            .curve(d3.curveLinearClosed)
            .angle(d => kp_x(d.key))


        let kp_y

    function buildKp(){
        kp_y = d3.scaleLinear()
            .domain([d3.min(data_keys, d=>d.min), d3.max(data_keys, d=>d.max)])
            .range([kp_innerRadius, kp_outerRadius])

        let kp_xAxis = g => g
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .call(g => g.selectAll("g")
            .data(kp_x.ticks())
            .join("g")
                .call(g => g.append("path")
                    .attr("stroke", "#000")
                    .attr("stroke-opacity", 0.2)
                    .attr("d", d => `
                    M${d3.pointRadial(kp_x(d), kp_innerRadius)}
                    L${d3.pointRadial(kp_x(d), kp_outerRadius)}
                    `))
                .call(g => g.append("path")
                    .attr("id", d => "key-id-"+d)
                    .datum(d => [d, (d+1)%12])
                    .attr("fill", "none")
                    .attr("d", ([a, b]) => `
                    M${d3.pointRadial(kp_x(a), kp_innerRadius)}
                    A${kp_innerRadius},${kp_innerRadius} 0,0,1 ${d3.pointRadial(kp_x(b), kp_innerRadius)}
                    `))
                .call(g => g.append("text")
                .append("textPath")
                    .attr('font-size', '12')
                    .attr("startOffset", 0)
                    // .attr('stroke-position',"outside")
                    // .attr("stroke", "#fff")
                    // .attr("stroke-width", 5)
                    .attr("xlink:href", d => "#key-id-"+d)
                    .text(d => (d==0?'1='  + c_ScaleFromTone[circle_of_fifth[d]]: c_ScaleFromTone[circle_of_fifth[d]]))
                ))

        let kp_yAxis = g => g
            .attr("text-anchor", "middle")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .call(g => g.selectAll("g")
            .data(kp_y.ticks().reverse())
            .join("g")
                .attr("fill", "none")
                .call(g => g.append("circle")
                    .attr("stroke", "#000")
                    .attr("stroke-opacity", 0.2)
                    .attr("r", kp_y))
                .call(g => g.append("text")
                    .attr("y", d => -kp_y(d))
                    .attr("dy", "0.35em")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 5)
                    .text((x, i) => x>0?`${x.toFixed(0)}%`:'')
                .clone(true)
                    .attr("y", d => kp_y(d))
                .selectAll(function() { return [this, this.previousSibling]; })
                .clone(true)
                    .attr("fill", "currentColor")
                    .attr("stroke", "none")))



        const kp_svg = d3.select('#kp-diag').append("svg")
        .attr("viewBox", [-kp_width / 2, -kp_height / 2, kp_width, kp_height])
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round")

        // kp_svg.append("path")
        //     .attr("fill", "steelblue")
        //     .attr("fill-opacity", 0.05)
        //     .attr("d", area
        //         .innerRadius(d => kp_y(d.min))
        //         .outerRadius(d => kp_y(d.max))
        //         (data_keys))

        kp_svg.append("path")
            .attr("fill", "steelblue")
            .attr("fill-opacity", 0.08)
            .attr("d", area
                .innerRadius(d => kp_y(d.min))
                .outerRadius(d => kp_y(d.max))
                (data_keys))
            
        kp_svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-opacity", 0.4)
            .attr("stroke-width", 1.5)
            .attr("d", line
                .radius(d => kp_y(d.avg))
                (data_keys))
            
        
    
        kp_current_line = kp_svg.append("path")
            .attr("fill", "var(--main-color-20)")
            .attr("stroke", "var(--main-color)")
            .style("mix-blend-mode", "multiply")
            .attr("stroke-width", 1.5)
            .attr("d", line
                .radius(d => kp_y(d.in_years[colIndex]))
                (Object.values(data_keys_raw)))

        kp_last_line_data = Object.values(data_keys_raw).map(d => kp_y(d.in_years[colIndex]))

        kp_svg.append("g")
            .call(kp_xAxis)

        kp_svg.append("g")
            .call(kp_yAxis)

    }


    function updateKPDiag(){
        let data = Object.values(data_keys_raw)
        let rt
        let last_colIndex = colIndex
        kp_current_line.interrupt()
            .transition().duration(500)
            .attrTween('d', ()=>
                t=>line.radius((d,i) => d3.interpolate(kp_last_line_data[i], kp_y(d.in_years[colIndex]))(rt=t))(data)
            ).end().then(() =>{
                kp_last_line_data = data.map(d => kp_y(d.in_years[colIndex]))
            }).catch(e=>{
                kp_last_line_data = data.map((d,i) => d3.interpolate(kp_last_line_data[i], kp_y(d.in_years[last_colIndex]))(rt))
            })
        
    }

    </script>

    <!-- bpm diagram -->
    <script>
    
    const bpm_text_map = [
        '慢速 (＜90bpm)',
        '较慢 (90~120bpm)',
        '中速 (120~150bpm)',
        '较快 (150~180bpm)',
        '快速 (≥180bpm)',
    ]

    function buildBpmStack(data, ele){
        let margin = {top: 20, right: 30, bottom: 30, left: 30}
        let height = 300
        let width = 500

        let color = d3.scaleSequential()
            .domain([0,5])
            .interpolator(d3.interpolateCool)
        
        let x = d3.scaleBand().padding(0.1)
            .domain(heads.slice(2,13))
            .rangeRound([margin.left, width - margin.right])

        let y = d3.scaleLinear()
            .domain([0, 100]).nice()
            .range([height - margin.bottom, margin.top])

        let xAxis = g => g
            .attr("transform", `translate(0,${height - margin.bottom})`)
            .call(d3.axisBottom(x))

        let yAxis = g => g
            .attr("transform", `translate(${margin.left},0)`)
            .call(d3.axisLeft(y))


        let swatches = d3.select(ele).append('div')
            .selectAll('span')
            .data(bpm_text_map)
            .join('span')
            .attr('class','data-swatch')
            .attr('style', (d,i) => `--color: ${color(i)}`)
            .html(d=>d)

        let bp_svg = d3.select(ele).append('svg')
            .attr("viewBox", [0, 0, width, height]);

        bp_svg.append("g")
            .selectAll("g")
            .data(data)
            .join("g")
            .attr('class', 'hidden-label-group')
            .attr("transform", (d,i) => `translate(${x(d.year)} 0)`)
            .call(g => g.selectAll("g")
                .data(d => d.stack)
                .join("g")
                .call(g2=> g2.append('rect')
                    .attr("fill", (d,i) => color(i))
                    .attr("y", (d,i) => y(d.end))
                    .attr("width", x.bandwidth() - 1)
                    .attr("height", d => y(d.start) - y(d.end)))
                .call(g2=> g2.append('text')
                    .attr("y", (d,i) => y((d.start + d.end)/2))
                    .attr("x", (d,i) => (x.bandwidth() - 1) / 2)
                    .attr('text-anchor', 'middle')
                    .attr('alignment-baseline', 'central')
                    .attr('class', 'hidden-label')
                    .attr('fill', 'white')
                    .text(d=>`${(d.end - d.start).toFixed(0)}%`)
                )
            )

        bp_svg.append("g")
            .call(xAxis);

        bp_svg.append("g")
            .call(yAxis);
    }
            
    const bpms_length = bpm_text_map.length
    const data_bpms_raw = [...heads.map(
        e=>[...bpm_text_map.map(d=>0)]
    )]
    const data_bpms = [...heads.map(e=>{})]

    function readBpmData(){
        d3.dsv(",", "../data/bpms.csv", ()=>{}, (d) => {
            let key = +d.key
            data_bpms_raw.forEach((v,i)=>{
                v[key] = +d[heads[i]]
            })
        }).then(c=>{
            data_bpms_raw.forEach((v,i)=>{
                let last_p = 0
                data_bpms[i] = {
                    year: heads[i],
                    stack: [...v.map(e=>({
                        start: last_p,
                        end: (last_p=last_p+e),
                    }))]
                }
            })    
            console.log(data_bpms)
            buildBpmStack(data_bpms.slice(2), '#bpm-diag')
        })
    }
    readBpmData()

    </script>

    <!-- chord-one diagram  -->
    <script>
        function ChordOneDiagram(ele){
            const svg = d3.select(ele)
                .attr('viewBox',"-20,-20,700,700")

            const dis_g = svg.append('g')

            const size = [680,680]
            const padding = 3

            function buildLayout(data, value){
                // const D = d3.map(data, d => d);
                // const V = d3.map(data, value);
                // const I = d3.range(V.length).filter(i => V[i] > 0);

                // // Compute layout: create a 1-deep hierarchy, and pack it.

                const hir = d3.hierarchy({children: data}).sum(value)

                const root = d3.pack()
                    .size(size)
                    .padding(padding)
                    (d3.hierarchy({children: data})
                    .sum(value));

                return root
            }

            function buildChordCircle(parent){
                parent
                    .join(
                        enter => enter
                            .append('g')
                            .attr('class', 'circle-group')
                            .attr("opacity",1)
                            .attr('style', d=>`--this-color: var(--color-${d.data.bass});`)
                            .attr("transform", d => `translate(${d.x},${d.y}) scale(${d.r/28})`)
                            .on('click', (e,d)=>PlayChord(d.data.name))
                            .on('mousemove', (e,d)=>showChordTip(e,d.data.name))
                            .on('mouseleave', (e,d)=>hideChordTip(e))
                            .call(e=>e.append('circle')
                                .attr('class', 'circle-back')
                                .attr('r', 28)   
                                .attr("fill", d=>`url(#st-${d.data.bass})`)
                            ).call(e=>e.append('circle')
                                .attr('r', 24)
                                .attr('class', 'circle-cover')
                                .attr("fill", "#f6f6f6")
                            ).call(e=>e.append('text')
                                .attr('class', 'circle-text note-text')
                                .attr('text-anchor', 'middle')
                                .attr('alignment-baseline', 'central')
                                .attr('fill', 'black')
                                .attr('dy', '0.1rem')
                                .text(d=>d.data.name)
                                .attr('transform', d=>`scale(${5/Math.max(d.data.name.length,5)})`)
                            ).call(e=>e.append('text')
                                .attr('class', 'circle-text note-text perc-text')
                                .attr('text-anchor', 'middle')
                                .attr('alignment-baseline', 'central')
                                .attr('fill', 'black')
                                .attr('font-size', '8px')
                                .attr('dy', '18px')
                                .text(d=>`${d.data.sum.toPrecision(2)}%`)
                            ),
                        update => update
                            .call(e=>e.select('.perc-text').transition()
                                .delay((d,i,a)=> (1-i/a.length) * 500 + 500)
                                .duration((d,i,a)=> i/a.length * 500 + 500)
                                .textTween(function(d){
                                    let last = +this.textContent.slice(0,-1)
                                    let cur = d.data.sum
                                    return t=>d3.interpolateNumber(last,cur)(t).toPrecision(2)+'%'
                                })
                            )
                            .interrupt()
                            .transition()
                            .duration((d,i,a)=> (1-i/a.length) * 300 + 200)
                            .attr("opacity",(d,i,a)=> Math.pow(1-i/a.length, 3))
                            .transition()
                            .duration((d,i,a)=> i/a.length * 500 + 500)
                            .delay((d,i,a)=> (1-i/a.length) * 500)
                            .attr("transform", d => `translate(${d.x},${d.y}) scale(${d.r/28})`)
                            .transition()
                            .duration(700)
                            .delay((d,i,a)=> Math.pow(i/a.length,2) * 1000)
                            .attr("opacity", 1)
                            ,
                        exit => exit.remove(),
                    )

            }

            function build(data, calc_sum){
                let layout = buildLayout(data, calc_sum)

                dis_g
                    .selectAll('g')
                    .data(layout.leaves(), d=>d.data.name)
                    // .filter(d=>d.data !== undefined)
                    .call(buildChordCircle)


            }


            return {build}

        }

        const function_order_map = [0, 1, 4, 11, 7, 3, 5, 2, 9, 6, 10, 8]
        function getFunctionOrder(bass){
            return function_order_map[note_name_map[bass]]
            return (circle_of_fifth[note_name_map[bass]] + 1) % 12
        }

        const data_first_chords = {}
        function readFirstChordsData(){

            d3.dsv(",", "../data/first_chords.csv", ()=>{}, (d) => {
                let key = d.key
                let bass = GetChordBassNote(key)
                for(let column in d){
                    if (column=='key') continue
                    (data_first_chords[column] || (data_first_chords[column] = [])).push({
                        name: key,
                        bass,
                        sum: +d[column],
                    })
                }
                
            }).then(c=>{
                Object.values(data_first_chords).forEach(e=>e.sort((a,b)=>
                    (getFunctionOrder(a.bass) - getFunctionOrder(b.bass)) // * 5 + (b.sum - a.sum)
                ))
                
                console.log(data_first_chords)
                update_c1(colIndex)
                updateHandlers.push(update_c1)
            })

            d3.dsv(",", "../data/one_chords.csv", ()=>{}, (d) => {
                (data_one_chords[d.key] || (data_one_chords[d.key] = [])).push(...heads.map(e=>+d[e]))
            }).then(c=>{
                
            })

        }

        const update_c1 = (i) => C1_diagram.build(data_first_chords[heads[i]], 
            d=> d.sum > 1 ? Math.pow(d.sum,0.75) :Math.pow(d.sum,0.5))

        readFirstChordsData()
        const C1_diagram = ChordOneDiagram('#chord-one-diag > svg')


    </script>

    <!-- chord-final diagram -->
    <script>

        function ChordFinalDiagram(ele){
            const svg = d3.select(ele)
                .attr('viewBox',"-225,-225,450,450")

            const dis_g = svg.append('g')
            
            const arcPie = d3.arc()
                .innerRadius(140)
                .outerRadius(190)
                .padRadius(300)
                .padAngle(0.01)
                .cornerRadius(3)

            const arcPieData = d3.pie()
                .value(d => d.sum)
                .sort((a,b)=>(note_name_map[a.bass] - note_name_map[b.bass]))

            let _lastArcData

            let _currentArcData


            function build(data){
                if (_currentArcData) _lastArcData = _currentArcData
                let res = arcPieData(data)
                // _currentArcData = d3.map(res, d=>d.data.name)
                _currentArcData = {}
                res.forEach(e=>{
                    let {value, startAngle, endAngle} = e
                    _currentArcData[e.data.name]={startAngle, endAngle}
                })
                dis_g.selectAll('g')
                    .data(res, d=>d.data.name)
                    .join(
                        enter => enter.append('g')
                            .attr('class', 'arc-group')
                            .attr('opacity', 0)
                            .attr('style', d=>`--this-color: var(--color-${d.data.bass});`)
                            .on('click', (e,d)=>PlayChord(d.data.name))
                            .on('mousemove', (e,d)=>showChordTip(e,d.data.name))
                            .on('mouseleave', (e,d)=>hideChordTip(e))
                            .call(g => g
                                .append("path")
                                .attr("d", arcPie)
                                .attr('class', 'arc-middle')
                                .attr("fill", d=>`url(#st-${d.data.bass})`)
                            ).call(e=>e.append('text')
                                .attr('class', 'arc-outer-text note-text')
                                .attr('text-anchor', 'middle')
                                .attr('alignment-baseline', 'central')
                                .attr('transform', d=> `translate(${arcPie.centroid(d).map(v=>v*1.25).join(",")})`)
                                .attr('fill', 'black')
                                .attr('font-size', '10px')
                                .text(d=>d.data.name)
                            ).call(e=>e.append('text')
                                .attr('class', 'arc-text note-text perc-text')
                                .attr('text-anchor', 'middle')
                                .attr('alignment-baseline', 'central')
                                .attr('transform', d=> `translate(${arcPie.centroid(d).join(",")})`)
                                .attr('fill', 'black')
                                .attr('font-size', '8px')
                                .text(d=>`${d.data.sum.toFixed(0)}%`)
                            )
                            .transition().duration(500)
                            .attr('opacity', 1)
                        ,
                        update=>update
                            .call(g=>g.select('path')
                                .attr("d", arcPie)
                            )
                            .call(g=>g.select('.arc-outer-text')
                                .attr('transform', d=> `translate(${arcPie.centroid(d).map(v=>v*1.25).join(",")})`)
                            )
                            .call(g=>g.select('.arc-text')
                                .attr('transform', d=> `translate(${arcPie.centroid(d).join(",")})`)
                                .text(d=>`${d.data.sum.toFixed(0)}%`)
                            )
                        ,
                        exit=>exit.transition().duration(500).attr('opacity',0).remove()
                    )

            }

            return {build}
        }

        const data_final_chords_raw = {}
        const data_final_chords = {}
        function readFinalChordsData(){

            d3.dsv(",", "../data/final_chords.csv", ()=>{}, (d) => {
                let key = d.key
                let bass = GetChordBassNote(key)
                for(let column in d){
                    if (column=='key') continue
                    (data_final_chords_raw[column] || (data_final_chords_raw[column] = [])).push({
                        name: key,
                        bass,
                        sum: +d[column],
                    })
                }
                
            }).then(c=>{

                for (let key in data_final_chords_raw){
                    e = data_final_chords_raw[key]
                    e.sort((a,b)=>b.sum - a.sum)

                    let filtered = e.slice(0,12)

                    filtered.sort((a,b)=>
                        (note_name_map[a.bass] - note_name_map[b.bass])
                    )
                    let sum = 0
                    filtered.forEach(v=>sum+=v.sum)
                    
                    filtered.push({
                        name: 'Other',
                        bass: '0',
                        sum: 100 - sum,
                    })

                    data_final_chords[key] = filtered
                }
                console.log(data_final_chords)
                update_cf(colIndex)
                updateHandlers.push(update_cf)
            })

        }

        const update_cf = (i) => CF_diagram.build(data_final_chords[heads[i]])

        const CF_diagram = ChordFinalDiagram('#chord-final-diag > svg')
        readFinalChordsData()
        // CF_diagram.build([
        //     { bass: 'b6', count: 12, name:'III/#5' },
        //     { bass: '4', count: 5, name:'IVmM7' },
        // ])

    </script>

</body>