<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <title>Chord Visualization</title>
    <link href=".\node_modules\bootstrap\dist\css\bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">

    <style>

        .chord-info{
            position: absolute; 
            z-index: 1070;
            margin: 0;
            background-color: white;
            word-wrap: break-word;
            opacity: 0;
            width: 150px;
            height: 80px;
            box-shadow: 0px 6px 20px 5px rgb(0 0 0 / 20%);
            border-radius: 8px;
        }


        
        :root {
            --main-color: #4a05a0;

            --color-1: #ff6060;
            --color-b2: #ff724b;
            --color-2: #f59f30;
            --color-b3: #e4b52e;
            --color-3: #d2ca34;
            --color-4: #78f659;
            --color-b5: #1db9d0;
            --color-5: #5464d6;
            --color-b6: #6b44b2;
            --color-6: #8f3db2;
            --color-b7: #b43cb1;
            --color-7: #d33ea8;
        }
        body {
            line-height: 1.5;
            -webkit-text-size-adjust: 100%;
            -o-tab-size: 4;
            tab-size: 4;      
            font-feature-settings: normal;
        }

        .large-title {
            padding-top:200px
        }

        #large-bg{
            filter:blur(2px) saturate(40%);
            
        }

        .hero {
            height: 800px;
            background: linear-gradient(15deg, #87bdfa57, #de72de40);
        }

        svg text{
            user-select: none;
        }

        .trans > *{
            transition: 500ms;
        }

        .tween {
            transition: 500ms
        }


        .fade-out{
            transform: translateY(-50px);
        }



        #prog-list{
            width: 420px;
            /* padding-left:   30px;
            padding-right: 20px; */
            height: 600px;
            overflow-y: scroll;
            border-radius: 4px;
            border: 1px solid rgb(30 13 62 /33%);
        }
        
        #my_dataviz{
            height: 600px;
        }


        .note-text {
            font-family: 'DejaVu Math TeX Gyre';
            text-align: center;
            line-height: 1rem;
            letter-spacing: -0.05rem;
            user-select: none;
                /* display: flex;
                align-items: center */
        }
        .note-text > span{
            font-size: 50%;
            letter-spacing: -0.1rem;
        }


        .chord-block>div, .chord-block svg{
            width: 80px;
            height: 50px;
        }

        .chord-text-fgn{
            height: 100%;
            display: flex;
            align-content: center;
            align-items: center;
            flex-wrap: nowrap;
            justify-content: center;
            word-break: break-all;
            text-align: center;
        }


        .chord-block:hover{
            filter: drop-shadow(0 0 2em var(--this-color));
        }
        .b-example-divider {
            height: 3rem;
            background-color: rgba(0, 0, 0, .1);
            border: solid rgba(0, 0, 0, .15);
            border-width: 1px 0;
            box-shadow: inset 0 0.5em 1.5em rgb(0 0 0 / 10%), inset 0 0.125em 0.5em rgb(0 0 0 / 15%);
        }

        #time-picker{
            background-color: rgb(230,230,230);
            padding: 0;
            border: none;
        }

        #time-picker > div{
            text-align: center;
            height: 100%;
            display: flex;
            align-content: center;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: 200ms;
        }


        #time-picker > .selected{
            background-color: rgb(112 97 141 / 60%);
            color: white;
            font-weight: bold;
            border-bottom: 6px solid rgb(74 5 160 / 90%)!important;
        }

        #time-picker > div:hover{
            color: white;
            background-color: rgba(21, 7, 72, 0.3);
            border-bottom: 4px solid rgba(74, 5, 160, 0.502);
        }
        
        .histogram {
            width: 190px;
            height: 50px;
            padding: 0 2px;
        }

        .histogram .hist-bar:hover{
            fill: rgba(21, 7, 72, 0.4);
        }

        .hist-text{
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            flex-direction: column;
        }

        .unit-main{
            
            color: rgb(39 40 152);
        }

        .unit-small{
            font-size: 10px;
            color: rgb(152, 142, 174);
        }

        .prog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pb-6{
            padding-bottom: 6rem!important;
        }

        .selected-arc {
            filter: url(#glow);
        }

        .bass-prog {
            text-align: left;
        }

        [v-cloak] {
            opacity: 0;
        }

        .info-chord-text-fgn{
            height: 100%;
            display: flex;
            align-items: flex-end;
            flex-wrap: nowrap;
            word-break: break-all;
            justify-content: flex-end;
            flex-direction: column;
        }

        .info-chord-text-fgn .note-text{
            line-height: 1.5;
            font-size: 48px;
        }

        #kp-diag{
            display: flex;
            justify-content: center;
        }

        #kp-diag svg{
            width: 750px;
        }

    </style>

</head>

<body>
    <svg class="position-absolute">
        <defs>
            <pattern id="st-1"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-1)" />
            </pattern>
            <pattern id="st-b2"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-1)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-2); stroke-width:1.414" />
            </pattern>
            <pattern id="st-2"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-2)" />
            </pattern>
            <pattern id="st-b3"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-2)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-3); stroke-width:1.414" />
            </pattern>
            <pattern id="st-3"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-3)" />
            </pattern>
            <pattern id="st-4"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-4)" />
            </pattern>
            <pattern id="st-b5"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-4)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-5); stroke-width:1.414" />
            </pattern>
            <pattern id="st-5"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-5)" />
            </pattern>
            <pattern id="st-b6"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-5)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-6); stroke-width:1.414" />
            </pattern>
            <pattern id="st-6"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-6)" />
            </pattern>
            <pattern id="st-b7"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-6)" />
                <path transform="scale(8)" d="M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2" 
                      style="stroke:var(--color-7); stroke-width:1.414" />
            </pattern>
            <pattern id="st-7"  patternUnits="userSpaceOnUse"  width="32" height="32">
                <rect width="32" height="32" style="fill:var(--color-7)" />
            </pattern>

            <pattern id="dash-line"  patternUnits="userSpaceOnUse"  width="6" height="2">
                <rect width="3" height="2" style="fill:rgba(255,255,255,0.5)" />
                <rect width="6" x="3" height="2" style="fill:#6b5393ee" />
            </pattern>
            <filter id="glow">
				<fegaussianblur class="blur" result="coloredBlur" stddeviation="2"></fegaussianblur>
				<femerge>
					<femergenode in="coloredBlur"></femergenode>
                    <femergenode in="coloredBlur"></femergenode>
                    <femergenode in="coloredBlur"></femergenode>
					<femergenode in="SourceGraphic"></femergenode>
				</femerge>
			</filter>
        </defs>
    </svg>


    <div id="app">
        <chord-info :chord="currentShownChordTip"></chord-info>

            
        <div class="bg-dark text-secondary text-center hero d-flex flex-wrap">
            
            <svg class="flex-grow-1">
                <g id="large-bg"></g>
                <g>
                    <text class="display-5 fw-bold text-white" fill="white" x="50%" y="300" text-anchor="middle" >
                        Data Visualization of Chord Progressions
                    </text>
                    <text class="lead" fill="rgb(155,187,155)" x="50%" y="390" text-anchor="middle" >
                        J-pop 中和弦进行的使用趋势和数据可视化
                    </text>
                    <text class="lead" fill="rgb(155,155,155)" x="50%" y="640" text-anchor="middle" >
                        Data from ja.chordwiki.org
                    </text>
                </g>
            </svg>
        </div>
        

        <div class="b-example-divider align-items-center sticky-top row m-0 w-100" id="time-picker">
            <div v-for="(column,index) in heads" :class="`col${index==colIndex?' selected':''}`"
                 @click="SelectHeadIndex(index)" v-cloak>
                {{ column.toUpperCase() }}
            </div>
        </div>

        <div class="px-4 pt-5 mt-5 text-center">
            <h1 class="display-6 fw-bold">主调雷达图</h1>
            <div class="col-lg-6 mx-auto">
                <p class="lead mb-4">
                    统计了各音乐主调的占比
                </p>
            </div>
        </div>



        
        <div id="kp-diag" class="pb-5">

        </div>

        <div class="b-example-divider"></div>

        <div class="px-4 pt-5 mt-5 text-center">
            <h1 class="display-6 fw-bold">和弦接续图</h1>
            <div class="col-lg-6 mx-auto">
                <p class="lead mb-4">
                    统计了音乐中任意两个相邻和弦连接的出现率
                </p>
            </div>
        </div>



        <div id="chord-diag" class="pb-6 border-bottom">

            <div id="my_dataviz" class="d-flex justify-content-center">
                <div id="chord-diagram">
                    
                    <div class="d-flex justify-content-center">
                        <div id="chord-title" class="pt-4"></div>
                    </div>
                </div>
                <div>
                    <div class="prog-header py-2" v-if="currentProgressionPoss">
                        <div class="note-text bass-prog" v-cloak>
                            {{ currentProgressionName }}
                        </div>
                        <!-- <div class="ps-4 unit-small flex-grow-1" v-cloak>{{ `${(CalcWeightPercentage() * 100).toFixed(1)}%` }}</div> -->

                        <div>
                            <span class="unit-small" v-if="currentProgressionPoss != ''">出现率：</span>
                            <span class="unit-main" v-cloak>
                                {{ currentProgressionPoss }}
                            </span>
                            <span class="unit-small" v-if="currentProgressionPoss != ''">次/曲</span>
                        </div>

                    </div>  
                    <div id="prog-list" class="d-flex flex-column">

                        <div class="flex-grow-1 d-block">
                            <Progression v-for="{chords, p, hist} in GetDeriveredProgressions(currentProgression)"
                                :key="chords" :data="chords" :p="p" :hist="hist" :max="currentProgressionMax"
                                :col="colIndex"
                                @select-column="SelectHeadIndex"
                                @select-chord="SelectChord"
                                @chord-tip="chordTip"
                            />
                        </div>
                    </div>
                </div>

            </div>


        </div>

        <div class="b-example-divider"></div>

    </div>


    <template id="t-progression">
        <div class="d-flex flex-row chord-line">
            <div class="chord-block tween" 
                v-for="(chord,i) in data" 
                @mouseover="$emit('chordTip', $event, chord)" @mouseleave="hideChordTip"
                @click.stop="$emit('selectChord', chord, i)"
                :style="`--this-color: var(--color-${GetChordBassNote(chord)});`" >
                <svg class="chord-svg" >
                    <rect x="1%" y="2%" width="98%" height="82%" fill="#f6f6f6"/>
                    <rect x="1%" y="84%" width="98%" height="14%" :fill="`url(#st-${GetChordBassNote(chord)})`"/>
                    <foreignObject width="100%" height="100%">
                        <div class="chord-text-fgn">
                            <div class="note-text" v-html="ReplaceBracket(chord)"></div>
                        </div>
                    </foreignObject>
                </svg>
            </div>
            <div class="flex-grow-1 d-flex">
                <svg class="histogram">
                    <rect v-for="(v,i) in hist" class="hist-bar"
                        :x="`${(i<2?i:i+0.3)/(hist.length+0.3)*100}%`"    :y="`${(1-v/max*0.8)*100}%`"
                        :width="`${1/(hist.length+0.3)*95}%`"        :height="`${v/max*80}%`" 
                        :fill="isCurrentCol(i)?'#4a05a0':'#555'"
                        @click.stop="$emit('selectColumn', i)"
                        @mouseover ="watchingIndex=i"
                        @mouseleave="watchingIndex=-1"
                        :title="`${v.toFixed(3)}次/曲 - ${GetColTitle(i)}`"
                    />
                    <rect 
                        :x="`${2/(hist.length+0.3)*100}%`"    :y="`${(1-hist[1]/max*0.8)*100}%`"
                        :width="`${hist.length/(hist.length+0.3)*95}%`"  height="2%" 
                        fill="url(#dash-line)" stroke-dasharray="5,5"        
                    />
                </svg>
                <div class="hist-text">
                    <div class="unit-main" v-cloak>
                        {{ watchingIndex==-1 ? p.toFixed(3): hist[watchingIndex].toFixed(3) }}
                    </div>
                    <div class="unit-small">
                        {{ watchingIndex==-1 ? '次/曲': headsTrunc[watchingIndex] }}
                    </div>
                </div>
            </div>
        </div>
    </template>

    <template id="t-chord-info">
        <div class="chord-info">
            <svg width="100%" height="100%">
                <rect x="0%" y="90%" width="100%" height="10%" :fill="`url(#st-${GetChordBassNote(chord)})`"/>
                <!-- <text x="50%" y="50%" text-anchor="middle" font-size="24px" fill="black">{{ ReplaceBracket(chordToText(chordObj)) }}</text> -->


                <foreignObject width="100%" height="100%">
                    <div class="chord-text-fgn">
                        <div v-html="ReplaceBracket(chordToText(chordObj))"></div>
                    </div>
                </foreignObject>
            </svg>
        </div>
    </template>


    <script src=".\node_modules\d3\dist\d3.js"></script>
    <script src=".\node_modules\tone\build\Tone.js"></script>
    <script src=".\node_modules\vue\dist\vue.global.js"></script>
    <script src=".\scripts\chorddiag.js"></script>





    <script>


        const data_of_years = {}
        const data_two_chords = {}  
        const data_keys_raw = {}      
        const data_keys = []
        let colIndex = 0
        let playIndex = 0        
        let currentChordFilter = null
        let currentSelectedBass = 0
        let currentMatrixSum = 0
        let isFromMode = true
        
        const heads = ['total', 'weighted',
              '2012', '2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022']
        const headsTrunc = ['TOTAL', 'WEIGHT',
              '2012', '2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022']

        const headsTitle = ['总计', '热门总计 (2012-2022年)',
              '2012年热门', '2013年热门', '2014年热门', '2015年热门', '2016年热门',
              '2017年热门', '2018年热门', '2019年热门', '2020年热门', '2021年热门', '2022年热门']

    </script>



    <script>

        const noteFromTone = ['1','b2','2','b3','3','4','b5','5','b6','6','b7','7']
        const c_ScaleFromTone = ['C','C♯/D♭','D','D♯/E♭','E','F','F♯/G♭','G','G♯/A♭','A','A♯/B♭','B']
        const scaleFromTone = ['1','♯1/♭2','2','♯2/♭3','3','4','♯4/♭5','5','♯5/♭6','6','♯6/♭7','7']

        const chord_name_map = {
            'bI'   : 11, 'I'   : 0,  '#I'   : 1,
            'bII'  : 1,  'II'  : 2,  '#II'  : 3,
            'bIII' : 3,  'III' : 4,  '#III' : 5,
            'bIV'  : 4,  'IV'  : 5,  '#IV'  : 6,
            'bV'   : 6,  'V'   : 7,  '#V'   : 8,
            'bVI'  : 8,  'VI'  : 9,  '#VI'  : 10,
            'bVII' : 10, 'VII' : 11, '#VII' : 0,
        }
        const note_name_map = {
            'b1' : 11, '1' : 0,  '#1' : 1,
            'b2' : 1,  '2' : 2,  '#2' : 3,
            'b3' : 3,  '3' : 4,  '#3' : 5,
            'b4' : 4,  '4' : 5,  '#4' : 6,
            'b5' : 6,  '5' : 7,  '#5' : 8,
            'b6' : 8,  '6' : 9,  '#6' : 10,
            'b7' : 10, '7' : 11, '#7' : 0,
        }
        const reg_chordname = /[#b]?(?:VI{1,2}|I?V|I{1,3})/
        const reg_bassname = /\/([#b]?[1-7])/

        function GetChordBass(chord){
            let match_bassname = reg_bassname.exec(chord)
            if (match_bassname)
                return note_name_map[match_bassname[1]]

            let match_chordname = reg_chordname.exec(chord)
            if (match_chordname)
                return chord_name_map[match_chordname[0]]

            return 0
        }

        const GetChordBassNote = (chord) => noteFromTone[GetChordBass(chord)]

        const ReplaceBracket = (text) =>
            text.replace(/#/,"♯")
                .replace(/b/, "♭")
                .replace(/(\(.*?\))/,"<span>$1</span>")
         

        let progression_index = 0
        let progressions = [
            ['IV', 'V', 'IIIm', 'VIm'],
            ['VIm', 'IV', 'V', 'I'],
            ['IV', 'III', 'VIm', 'I'],
            ['I', 'III', 'VIm', 'II'],
        ]

        // let shown_progression = ['IV', 'V', 'IIIm', 'VIm']

        function update_largeBg(prog){
          
            const largeBg = d3.select("#large-bg")
            

            const rect = (e,delay) =>
                e.append('rect').attr('y','-20%').attr('width','25%').attr('height','140%')
                    .style("mix-blend-mode", "hue")
                    .style("fill", d=>`url(#st-${GetChordBassNote(d)})` ).style('opacity','0')
                    .transition().duration(1500).delay(delay).style('opacity','0.01')
                    .attr('x', (d,i)=>`${i*25}%`)

            const text = (e,delay) =>
                e.append('text').attr('y','85%')
                    .attr('class', 'chord-score chord-name')
                    .style('font-size','64').attr('fill', 'white')
                    .attr('text-anchor', 'middle')
                    .text((d,i)=>d).style('opacity','0')
                    .transition().duration(1500).delay(delay).style('opacity','0.01')
                    .attr('x', (d,i)=>`${(i+0.5)*25}%`)

            const delay = (d,i)=>i*500

            largeBg.selectAll('g').data(prog) //, d=>d)
                .join(
                    enter => {
                        let g = enter.append('g')
                        rect(g, delay)
                        text(g, delay)
                        return g 
                    },
                    update => {
                        update.select('rect').transition().duration(1400).delay(delay).attr('x', (d,i)=>`${i*25}%`).style('opacity','0').remove()
                        update.select('text').transition().duration(1400).delay(delay).attr('x', (d,i)=>`${(i+0.5)*25}%`).style('opacity','0').remove()
                        rect(update, delay)
                        text(update, delay)
                        return update
                    },
                    exit => exit.selectAll('*').transition().style('opacity','0').remove()
                )
  
        }
        update_largeBg(progressions[0])

        d3.select("#large-bg").on('click', (e,d)=>{
            progression_index = (progression_index+1)%4
            update_largeBg(progressions[progression_index])
        })
    </script>
    
    <script>

        let chordTip = null
        const showChordTip = function(event, chord) {
            chordTip = chordTip || d3.select('#chord-info')
            chordTip
                .style("left", (event.x-75) + "px")
                .style("top", (event.y + window.pageYOffset -120) + "px")
                .style('display', 'block')
                .transition().duration(100)
                .style("opacity", 0)
        }

        var hideChordTip = function(event) {
            chordTip.interrupt()
                .transition()
                .duration(300)
                .style("opacity", 0)
                .end().then(() => 
                    chordTip.style('display', 'none')
                        .style("left","0px")
                        .style("top", "0px")
                ).catch(e=>{})
        }


        const bassNotes = ['G3','Ab3','A3','Bb3','B3','C4','Db4','D4','Eb4','E4','F4','Gb4','G4','Ab4']
        const glassNotes = ['B3',
            'C4','Db4','D4','Eb4','E4','F4','Gb4','G4','Ab4','A4','Bb4','B4',
            'C5','Db5','D5','Eb5','E5','F5','Gb5','G5','Ab5','A5','Bb5','B5',
            'C6','Db6','D6','Eb6','E6','F6','Gb6','G6','Ab6','A6','Bb6',
        ]

        const synthA = new Tone.PolySynth(Tone.FMSynth).toDestination();
        const synthB = new Tone.PolySynth(Tone.AMSynth).toDestination();

        const bass = new Tone.Sampler({
            urls: (()=>{
                let res = {}
                Array(...bassNotes).forEach(e => {
                    res[e] = `${e}.mp3`
                })
                return res
            })(),
            release: 1,
            baseUrl: "../sound/bass/",
        }).toDestination();

        const glass = new Tone.Sampler({
            urls: (()=>{
                let res = {}
                Array(...glassNotes).forEach(e => {
                    res[e] = `${e}.mp3`
                })
                return res
            })(),
            release: 1,
            baseUrl: "../sound/glass/",
        }).toDestination();

    </script>


    <script>
        const app = Vue.createApp({
            data() { return {
                currentProgression: [],
                currentProgressionMax: 0,
                heads, colIndex:0,
                currentProgressionName: '',
                currentProgressionPoss: '',
                currentShownChordTip: '',
            }},
            computed:{

            },
            methods:{
                chordTip(e, c){
                    showChordTip(e, c)
                    this.currentShownChordTip = c
                },
                GetDeriveredProgressions(prog){
                    let r = (data_two_chords[prog.join(' ')]||[]).map(
                        ({chords, in_years})=>({
                            chords, 
                            p: (in_years[colIndex]||0.0), 
                            hist: in_years,
                        })
                    )
                    this.currentProgressionMax = Math.max(...r.map(e=>Math.max(...e.hist)))
                    // r.sort((a,b)=>b.p-a.p)
                    return r
                },
                SelectHeadIndex(index, t){
                    this.colIndex = colIndex = index
                    let mat = matrixFromColumn(data_of_years, heads[this.colIndex], currentChordFilter)
                    
                    if(t) 
                        update(mat, 
                            currentChordFilter
                            ? `${headsTitle[colIndex]} - ${t}和弦低音为 <span class="note-text">${scaleFromTone[currentSelectedBass]}</span>`
                            : headsTitle[colIndex])
                    else
                        update(mat, 
                            currentChordFilter
                            ? `${headsTitle[colIndex]} - 起始和弦低音为 <span class="note-text">${scaleFromTone[currentSelectedBass]}</span>`
                            : headsTitle[colIndex])

                    if (this.currentProgression[0]){
                        
                        this.currentProgressionName = `${scaleFromTone[this.currentProgression[0]]} → ${scaleFromTone[this.currentProgression[1]]}`
                        this.currentProgressionPoss = (+currentMatrix[this.currentProgression[0]][this.currentProgression[1]]).toFixed(3)
                    
                    }
                    updateKPDiag()
                },
                CalcWeightPercentage(){
                    return (+this.currentProgressionPoss) / currentMatrixSum
                },
                SelectChord(chord, index){
                    currentSelectedBass = GetChordBass(chord)
                    currentChordFilter = index==0? (f,t)=>t==currentSelectedBass :  (f,t)=>f==currentSelectedBass
                    this.currentProgression[1 - index] = currentSelectedBass

                    this.SelectHeadIndex(this.colIndex, index==0?'目标':'起始')
                    isFromMode = index==0
                }
                // GetDataFromYear(data){
                //     return data[colIndex] || 0
                // }
            }
        })
        app.component('Progression', {
            template: '#t-progression',
            props: ['data', 'p', 'hist', 'max', 'col'],
            data(){ return{
                watchingIndex: -1,
                headsTrunc
            }},
            methods:{
                GetChordBassNote, 
                hideChordTip,
                GetCurrentDataHtml(cols){
                    return ReplaceBracket(cols[colIndex])
                },
                ReplaceBracket,
                isCurrentCol(index){
                    return index==this.col
                },
                GetColTitle(col){
                    return headsTitle[colIndex]
                }
            },
        })
        app.component('ChordInfo', {
            template: '#t-chord-info',
            props: ['chord'],
            data(){ return{

            }},
            computed: {
                chordObj(){
                    return parseChord(this.chord) || {};
                }
            },
            methods:{
                GetChordBassNote, 
                ReplaceBracket,
                chordToText,
            },
        })

        app.mount('#app')

        chordTip = d3.select('.chord-info')
    </script>


    <script>
        let width = 500

        range = length => [...Array(length).keys()]


        // d3.select('#time-picker').selectAll('div')
        //     .data(heads).join('div')
        //     .attr('class', 'col')
        //     .text(d=>d.toUpperCase())
        //     .on('click', (e,d)=>{
        //         colIndex = (colIndex+1) % 13
        //         let mat = matrixFromColumn(data_of_years, heads[colIndex])
        //         update(mat, heads[colIndex])
        //     })
        //     .filter((d,i)=>i==0).attr('class','col selected')




            // let now = Tone.now()
            // synthA.triggerAttackRelease("G4", "8n", now)
            // synthA.triggerAttackRelease("Bb4", "8n", now+0.05, 0.6)
            // synthA.triggerAttackRelease("E5", "8n", now+0.1, 0.3)
            // synthA.triggerAttackRelease("D6", "8n", now+0.15, 0.15)
            // synthB.triggerAttackRelease("C3", "8n", now)

            
            // bass.releaseAll("+0")
            // glass.releaseAll("+0")

        
        d3.dsv(",", "../data/conn_chords.csv", () =>{}, (d) => {
            for(let column in d){
                (data_of_years[column] || (data_of_years[column] = [])).push(d[column])
            }
            
        }).then(c=>{
            let mat = matrixFromColumn(data_of_years, 'total')
            update(mat, headsTitle[0])

        })

        d3.dsv(",", "../data/two_chords.csv", () =>{}, (d) => {
            (data_two_chords[d.semi] || (data_two_chords[d.semi] = [])).push({
                chords: d.key.split(' '),
                in_years: [...heads.map(e=>+d[e])]
            })
        }).then(c=>{
            console.log(data_two_chords)

        })

        d3.dsv(",", "../data/keys.csv", () =>{}, (d) => {
            if( (+d.key) < 0) return 
            data_keys_raw[+d.key] = {
                key: +d.key,
                in_years: [...heads.map(e=>+d[e])]
            }
        }).then(c=>{
            data_keys.push(...Object.values(data_keys_raw).map(({key, in_years})=>({
                key,
                total: in_years[0],
                avg: in_years[1],
                min: d3.min(in_years.slice(2,13)),
                max: d3.max(in_years.slice(2,13)),
            })))
            console.log(data_keys)
            buildKp()
        })

        
    </script>

    <script>



    const showProgDetail = function(event, d) {
        let data = app._instance.data
        data.currentProgression = [d.source.index, d.target.index]//.map(e=>`/${e}`)
        data.currentProgressionName = `${scaleFromTone[d.source.index]} → ${scaleFromTone[d.target.index]}`
        data.currentProgressionPoss = (+currentMatrix[d.source.index][d.target.index]).toFixed(3)
    }


    const title = d3.select("#chord-title").text('what')


    // create the svg area
    const svg = d3.select("#chord-diagram")
      .append("svg")
        .attr("width", 800)
        .attr("height", 600)
        // .attr('viewBox', '-300 -300 300 300')
      .append("g")
        .attr('alignment-baseline', 'central')
        .attr("transform", "translate(400,300)")
    
    const arcs =  svg.append("g").attr('id', 'chord-arcs')
    const ribbons = svg.append("g").attr('id', 'chord-ribbons')
    const arcTexts = svg.append('g').attr('id', 'chord-root')

    const ribbonPathGenerator = d3.ribbonArrow().radius(247).headRadius(30)
    const arcPathGenerator = d3.arc().innerRadius(250).outerRadius(270)



    const GetTranslate = (angle, width, height) => 
        `translate(${Math.sin(angle) * width} ${-Math.cos(angle) * height})`
    
    const GetArcTextTranslate = 
        ({startAngle, endAngle}, width, height) => GetTranslate((startAngle + endAngle)/2, width, height)
    

    const GetRibbonKey = ({source: {index: x0}, target: {index: x1}}) => 1 ? `${x0}-${x1}` : `${x1}-${x0}`

    function CacheChordData(data){
        let dict = {}

        for (let i = 0; i < data.length; i++) {
            const datum = data[i]
            dict[GetRibbonKey(datum)] = datum
        }

        return dict
    }


    d3.select("#my_dataviz").on('click', e=>{
        if(!currentChordFilter) return
        let mat = matrixFromColumn(data_of_years, heads[colIndex])
        currentChordFilter = null
        update(mat, headsTitle[colIndex])
    })

    let lastRibbonData, currentRibbonData
    let lastArcData, currentArcData


    let currentMatrix
    function update(matrix, t){

        isFromMode = false

        currentMatrix = matrix
        title.html(t)
        
        lastRibbonData = currentRibbonData
        lastArcData = currentArcData

        var res = d3.chordDirected()
            .padAngle(0.02)
            .sortSubgroups(d3.ascending)
            .sortChords(d3.descending)
            (matrix)
        
        

        arcs.datum(res)
        .selectAll("path")
        .data(
            d => d.groups,
            d => d.index,
        )
        .join(
            enter => enter.append("path").attr("d", arcPathGenerator).attr('id',d => 'arc-'+d.index).each(d=>d.p=1)
                .style("opacity", 0)
                .classed('selected-arc', (d,i)=> currentChordFilter && i==currentSelectedBass)
                .transition().duration(500).style('opacity', 1),
            update => update.classed('selected-arc', (d,i)=> currentChordFilter && i==currentSelectedBass)
                .filter(d=>!d.exit).transition().duration(500).style('opacity', 1).style('transform','scale(1)')
                .attrTween('d', (d,i)=>
                    t=>arcPathGenerator(d3.interpolate(lastArcData[i], d)(d.p=t))
                ),
            exit => exit.transition().duration(500).style('opacity',0).remove()    
        )
        .style('opacity', 1)
        .style("fill", d=>`url(#st-${noteFromTone[d.index]})`)
        .on('click', (e,d)=>{
            if(currentSelectedBass != d.index || isFromMode || !currentChordFilter){
                let mat = matrixFromColumn(data_of_years, heads[colIndex], currentChordFilter = (f,t)=>f==d.index)
                currentSelectedBass = d.index
                update(mat, `${headsTitle[colIndex]} - 起始和弦低音为 <span class="note-text">${scaleFromTone[d.index]}</span>`)
            } else {
                let mat = matrixFromColumn(data_of_years, heads[colIndex], currentChordFilter = (f,t)=>t==d.index)
                currentSelectedBass = d.index
                update(mat, `${headsTitle[colIndex]} - 目标和弦低音为 <span class="note-text">${scaleFromTone[d.index]}</span>`)
                isFromMode = true
            }
            e.stopPropagation()
        })
        .on("mouseover", (e,d)=>{
            if(isFromMode){
                if(currentChordFilter && currentSelectedBass!=d.index)
                    showProgDetail(e,{target:{index: currentSelectedBass}, source:{index: d.index}})
            }else {
                if(currentChordFilter && currentSelectedBass!=d.index)
                    showProgDetail(e,{source:{index: currentSelectedBass}, target:{index: d.index}})
            }

            fade(0.05, 0.3)(e,d)
            d3.select(e.target).filter(d=>d.p==1).interrupt().
                transition().style('opacity', 1).style('transform','scale(1.02)')
        })
        .on("mouseleave", (e,d)=>{
            fade(0.8, 1)(e,d)
            d3.select(e.target).filter(d=>d.p==1).interrupt().
                transition().style('opacity', 1)  .style('transform','scale(1)')
        })


        arcTexts.datum(res)
        .selectAll("text")
        .data(
            d => d.groups,
            d => d.index,
        )
        .join(
            enter => enter.append('text').attr("dy", "0.35em")// .style('user-select', 'none')
                .style("opacity", 0).transition().duration(500).style('opacity', 1),
            update => update.transition().duration(500).style('opacity',1)
                .attrTween('transform', (d,i)=> 
                    t=>GetArcTextTranslate(d3.interpolate(lastArcData[i], d)(t), 295, 285)
                ),
            exit => exit.transition().duration(500).style('opacity',0).remove()    
        )
        .attr('class', 'note-text')
        .attr('transform', d=>GetArcTextTranslate(d, 295, 285))
        .attr('text-anchor', 'middle')
        .text((d,i)=>scaleFromTone[i]);




        ribbons.datum(res)
        .selectAll("path")
        .data(d => d, d => GetRibbonKey(d))
        .join(
            enter => enter.append("path").each(d=>d.p=1).attr('d', ribbonPathGenerator).style("mix-blend-mode", "multiply")
                .style("opacity", 0).transition().duration(500).style('opacity',0.8),
            update => update.filter(d=>!d.exit).transition().duration(500).style('opacity',0.8)
                .attrTween('d', d=> 
                    t=>ribbonPathGenerator(d3.interpolate(lastRibbonData[GetRibbonKey(d)], d)(d.p=t))
                ),
            exit => exit.each(d=>d.exit = true).transition().duration(500).style('opacity',0).remove()   
        )
        .attr('ribbon-key', d => GetRibbonKey(d))
        .style("fill", d=>`url(#st-${noteFromTone[d.source.index]})` )
        .on("mouseenter", showProgDetail )
        // .on("mouseleave", hideTooltip )
        
        currentRibbonData = CacheChordData(res)
        currentArcData = res.groups
    }

    function matrixFromColumn(data, column, filter){
        let res = Array(12)

        let keys = data['key']
        let weights = data[column]
        

        for (let index = 0; index < 12; index++) {
            res[index] = Array(12)
        }

        currentMatrixSum = 0

        for(let i=0; i<keys.length; i++){
            let key = keys[i]
            let w = +weights[i]


            let chords = key.split(' ')

            let source = +chords[0]
            let target = +chords[1]

            if(filter){
                if(!filter(source, target)) {
                    res[source][target] = 0
                    continue
                }
            }
            
            
            currentMatrixSum += w
            res[source][target] = w
        }

        

        return res
    }



    const fade = (opacity, arcOp) => (event, datum) => {
        ribbons.selectAll("path").filter(d => d.source.index != datum.index && d.target.index != datum.index && d.p>0.999 && !d.exit)
            .transition().style("opacity", opacity);
    }


    
    </script>

    <script>
        const kp_width = 700
        const kp_height = 700
        const kp_margin = 10
        let kp_innerRadius = kp_width / 6
        let kp_outerRadius = kp_width / 2 - kp_margin

        let kp_current_line
        let kp_last_line_data

        let kp_x = d3.scaleLinear()
            .domain([0,12])
            .range([0, 2 * Math.PI])


        let line = d3.lineRadial()
            .curve(d3.curveLinearClosed)
            .angle(d => kp_x(d.key))

        let area = d3.areaRadial()
            .curve(d3.curveLinearClosed)
            .angle(d => kp_x(d.key))


        let kp_y

    function buildKp(){
        kp_y = d3.scaleLinear()
            .domain([d3.min(data_keys, d=>d.min), d3.max(data_keys, d=>d.max)])
            .range([kp_innerRadius, kp_outerRadius])

        let kp_xAxis = g => g
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .call(g => g.selectAll("g")
            .data(kp_x.ticks())
            .join("g")
                .call(g => g.append("path")
                    .attr("stroke", "#000")
                    .attr("stroke-opacity", 0.2)
                    .attr("d", d => `
                    M${d3.pointRadial(kp_x(d), kp_innerRadius)}
                    L${d3.pointRadial(kp_x(d), kp_outerRadius)}
                    `))
                .call(g => g.append("path")
                    .attr("id", d => "key-id-"+d)
                    .datum(d => [d, (d+1)%12])
                    .attr("fill", "none")
                    .attr("d", ([a, b]) => `
                    M${d3.pointRadial(kp_x(a), kp_innerRadius)}
                    A${kp_innerRadius},${kp_innerRadius} 0,0,1 ${d3.pointRadial(kp_x(b), kp_innerRadius)}
                    `))
                .call(g => g.append("text")
                .append("textPath")
                    .attr('font-size', '12')
                    .attr("startOffset", 0)
                    .attr("xlink:href", d => "#key-id-"+d)
                    .text(d=>c_ScaleFromTone[d])
                )
            )

        let kp_yAxis = g => g
            .attr("text-anchor", "middle")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .call(g => g.selectAll("g")
            .data(kp_y.ticks().reverse())
            .join("g")
                .attr("fill", "none")
                .call(g => g.append("circle")
                    .attr("stroke", "#000")
                    .attr("stroke-opacity", 0.2)
                    .attr("r", kp_y))
                .call(g => g.append("text")
                    .attr("y", d => -kp_y(d))
                    .attr("dy", "0.35em")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 5)
                    .text((x, i) => x>0?`${x.toFixed(0)}%`:'')
                .clone(true)
                    .attr("y", d => kp_y(d))
                .selectAll(function() { return [this, this.previousSibling]; })
                .clone(true)
                    .attr("fill", "currentColor")
                    .attr("stroke", "none")))



        const kp_svg = d3.select('#kp-diag').append("svg")
        .attr("viewBox", [-kp_width / 2, -kp_height / 2, kp_width, kp_height])
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round")

        kp_svg.append("path")
            .attr("fill", "lightsteelblue")
            .attr("fill-opacity", 0.2)
            .attr("d", area
                .innerRadius(d => kp_y(d.min))
                .outerRadius(d => kp_y(d.max))
                (data_keys))

        kp_svg.append("path")
            .attr("fill", "steelblue")
            .attr("fill-opacity", 0.2)
            .attr("d", area
                .innerRadius(d => kp_y(d.min))
                .outerRadius(d => kp_y(d.max))
                (data_keys))
            
        kp_svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-opacity", 0.7)
            .attr("stroke-width", 1.5)
            .attr("d", line
                .radius(d => kp_y(d.avg))
                (data_keys))
            
        
    
        kp_current_line = kp_svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "var(--main-color)")
            .attr("stroke-width", 1.5)
            .attr("d", line
                .radius(d => kp_y(d.in_years[colIndex]))
                (Object.values(data_keys_raw)))

        kp_last_line_data = Object.values(data_keys_raw).map(d => kp_y(d.in_years[colIndex]))

        kp_svg.append("g")
            .call(kp_xAxis)

        kp_svg.append("g")
            .call(kp_yAxis)

    }


    function updateKPDiag(){
        let data = Object.values(data_keys_raw)
        let rt
        kp_current_line.interrupt()
            .transition().duration(500)
            .attrTween('d', ()=>
                t=>line.radius((d,i) => d3.interpolate(kp_last_line_data[i], kp_y(d.in_years[colIndex]))(rt=t))(data)
            ).end().then(() =>{
                kp_last_line_data = data.map(d => kp_y(d.in_years[colIndex]))
            }).catch(e=>{
                kp_last_line_data = data.map((d,i) => d3.interpolate(kp_last_line_data[i], kp_y(d.in_years[colIndex]))(rt))
            })
        
    }

    </script>




</body>